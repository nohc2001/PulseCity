SyncFPS
{
	왜 Server의 Object는 Mesh 정보를 정수로 가져야 하는가 ?
	1. Mesh 정보는 너무커서 참조해야 함.
		그럼 포인터나 인덱스거나 스트링 / 해쉬데이터인데 일단 포인터는 Client와 달라서 안되고,
		인덱스는 되긴하는데 직관성떨어짐.그리고 해쉬는 좀 느리고 그러지만
		디버깅 용이함.
	2. Client는 언제 어디서 들어올지 모르는데, 그때마다 Mesh에 대한 초기화 정보를 주어야 함.근데 서버에는 Mesh 정보가 없음.때문에 어떤 메쉬를 가져올지 결정하는 뭔가가 있어야 함.
		그렇지만 string hash의 경우는 결국 원본 string이 있어야 탐색 가능하기 때문에 string을 GameObject 안에 넣어야 하는데 과부화가 옴.
		그럴거면 vector<string>하나를 만들어 GameObject에서 인덱스로 참조하는 것이 바람직하다 판단.


	왜 클라이언트와 서버의 Sizeof를 따로 두는가 ? 또 왜 클라이언트와 서버에 둘다 두 Sizeof를 가지게 하는가 ?
	GameObject의 자식별로 서버와 클라이언트 사이의 크기와 형식이 다르다.
	하지만 두개는 공유되어야 한다.하지만 정보의 전송에 있어서 클라이언트 사이즈를 보내는 것은 낭비다.
	그냥 두개다 가지고 있고, 클라가 데이터를 받았을때.서버에서 왔다면 서버의 Sizeof를 사용한다.

	Debug 모드와 Release 모드의 데이터 차이.
	Debug 모드가 vptr 다음 16바이트가 추가적으로 더 들어간다.아마 디버그를 위한 데이터인듯.
	그럼 어떻게 offset을 맞추어야 하는가 ?
	전송하는 입장에서는 상대가 Debug인지 Release인지 모른다.그러면 어떻게 offset을 다루어야 하는가 ?
	대안1.Release의 offset만 전송하고 자신의 모드에 따라 오프셋을 변경한다.

	따로 ? ?
	구조 다름. > 이해가 안될 수 있다..
	구조 익히면 생산성 향상

	따로따로
	익숙하지..

	염려.
	실수 ? 오류 만들까봐 ? ,

	일단 내가 모든걸 만들 수는 없음.
	시간 한정 >> 생산성 극대화 목표

	그림그리고 설명.내 생각
	>> 측정해봐야 아는것.

	어짜피 안될것 같은 그런 느낌쓰.
	>> 게속 들게 된다.

	너 뭐 하고 있냐 ?
	>> 게속 구조를 짜고 있음.
	이러면 어떤 문제가 생기고 그래서 이걸 해야 되고
	이걸 했는데 이러면 안될것 같고 ..
}

// 데이터를 한번에 보내기
{
	/*
	* 버퍼의 사이즈 제한이 8196이 있으니까, 그것들을 써서 한번에 데이터를 보내는 것을 개발한다.;
	* 첫번째 char는 데이터의 타입이니까, PACK 타입으로 설정한다.
	* 두번째 데이터 int는 현재 보내는 PACK의 몇번째 데이터인지 설정한다.
	* [PACK] [Data Order ID] [~ data ~ (8192 - 5)]
	* Fup을 사용해 데이터를 집어넣는다.
	*/
}