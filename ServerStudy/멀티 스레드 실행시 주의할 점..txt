멀티 스레드 실행시 주의할 점.
1. 스레드 분할하면서 작업도 분할한다면, 분할하는 작업이 비슷한 연산시간을 필요로 하는지 체크하는 것이 먼저 필요하다.
	-ex> 모든 소수를 한 vector에 수집하는 예제에서, 탐색 범위를 4등분 하여 소수를 찾아 넣는다면,
	- 숫자가 커질수록 더 많은 연산량을 가지기 때문에 이를 알맞게 조정하는 편이 좋다.
2. 작업 할당을 조절하는 법
	1. 미리 작업시간을 계산해서 분배한다.
		- y=x 의 작업시간을 가지는 알고리즘이라면, 결국 그 알고리즘을 0~N까지 한다면,
		해당 함수를 0~N까지 적분한 값이 계산량이라 볼 수 있다. 그 적분한 면적을 모두 같은 면적을 가지도록 분할하는 경계면의 x를 찾아야 한다.
		때문에 해당 함수를 적분한 함수의 역함수 A를 구하고, 최종 작업량을 구하고, 최종작업량을 A에서 x에 대입하고, 그 숫자를 스레드 개수만큼 나눈다.
		나눈 숫자들을 A에 대입하여 경계가 되는 x들을 구한다.
		ex> y=x -> y=0.5x^2 -> y=sqrt(2x)
			스레드 개수 : 4개, 필요작업량 : 0.5*150000^2
			x = 0 ~ sqrt(2 * (0.5*150000^2) / 4) = 150000/2 = 75000
			x = 75000 ~ sqrt(2 * 2 * (0.5*150000^2) / 4) = sqrt(2) * 75000 = 106066.017178
			x = 106066.017178 ~ ... sqrt(3) * 75000 = 129903.810568
			x = 129903.810568 ~ 150000
		//https://www.desmos.com/calculator/sezflmm8y6?lang=ko

		이렇게 하려면 코드를 보고 해당 코드의 실행량을 식으로 적을 수 있어야 하는데..
			>> 생각해보자..?
		하지만 이렇게 구하기 뭐하면 직접 시간을 재서 경계면을 추정하는 법도 있다.
	2. 한 스레드의 작업이 끝나면 다른 스레드의 작업을 실시간으로 가져온다.
		작업을 가져올 수 있도록 미리 작업을 정의해두어야 한다.
		혹은 작업을 넣고 뺄 수 있는 스택이나 큐를 만들어서 동시에 작업을 할 수 있도록 하는 것도 좋다.
	3. 작업 분할하지 않고 모든 스레드가 한 덩어리로 처리한다.
		- 동기화되는 객체가 늘어날 수 있다.
		- 하지만 스레드가 작업을 나누는 이유는, 캐시메모리 히트의 문제도 있기 때문에, 일반적으로는 작업을 나누는 것도 좋다.