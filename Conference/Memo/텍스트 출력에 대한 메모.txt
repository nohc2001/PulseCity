현재 이 메모는 DirectX 12 에서 텍스트 출력을 어떻게 하는지 알아보기 위하여 작성되었다.
때문에 후에 이 프로젝트에 대해 정말 심층적으로 다룰때는 다른 메모를 작성할 필요가 있다.

DirectX 공식 샘플의D3D12HDR의 결과 이미지를 보니 텍스트가 나와 있었다.
일단 D3D12HDR 클래스의 Render함수를 봤다.그런데 UIRender를 먼저하고 그 다음 렌더링을 한다.
그리고 UILayer라는 클래스를 사용해 렌더링을 하는 것 같다.
UILayer::Render() 함수를 가봤다.
신기한 것은 D2D 객체를 사용한다는 것이다.
m_d3d11On12Device를 사용해 AcquireWrappedResources이라는 함수를 호출한후, m_d2dDeviceContext으로 BeginDraw와 EndDraw 사이에 DrawText를 호출한다.

여기에서 정말 이걸 하는 것이 맞나 생각이 들었다.
다른 사람들은 DX11을 사용하지 않고 텍스트 렌더링을 하는지 한번 살펴봐야 겠다.
음 한 사람 봤는데 그 사람도 그렇게 한다.megayuchi
성능상으로 문제가 없는 방식인지도 알고 싶긴하다.
뭔가 느낌상 화면버퍼 리소스 하나만 만들어서 거기다 렌더링 하고 하는 거라 그렇게 비용을 요구하진 않을 것 같지만..
일단 AI한테 물어보고 정보의 출처를 물어보자.

-------------- - microsoft_copilot---------------- -
질문 : DirectX 12 에서 텍스트 렌더링을 하는데, DirectX 11과 D2D를 사용하는 경우가 있더라고.혹시 그렇게 많은 API를 한번에 사용할 경우 게임에서 성능저하가 얼마나 일어나는지, 혹은 일어나지 않는지, DirectX 12 공식문서를 출처로 한 정보를 제공해줄 수 있겠어 ? 링크와 함께 제시해줘.

답변 : 훌륭한 질문이에요, ??님.DirectX 12에서 텍스트 렌더링을 위해 DirectX 11과 Direct2D(D2D)를 함께 사용하는 경우, 성능에 영향을 줄 수 있는 몇 가지 중요한 요소가 있습니다.특히 D3D11On12 인터페이스를 통해 DX11 기반의 D2D를 DX12 환경에서 사용하는 방식은 성능 최적화에 신중함이 필요합니다.

성능 저하 가능성 : D3D11On12 + D2D 사용 시 고려사항
CPU / GPU 비동기 작업 제한 : DirectX 12의 핵심은 CPU와 GPU의 완전한 비동기 작업인데, D2D는 DX11 기반이므로 이 비동기성을 충분히 활용하지 못할 수 있습니다.

GPU Idle Time 증가 가능성 : D3D11On12를 사용할 경우 GPU가 대기 상태에 머무는 시간이 늘어날 수 있어, 전체 프레임 처리 속도에 영향을 줄 수 있습니다.

리소스 전환 오버헤드 : DXGI 상호 운용성에서 빈번한 전환은 성능 저하의 원인이 될 수 있으며, Microsoft는 이를 피하라고 권장합니다.

Flush 호출 최소화 권장 : D2D에서는 Flush() 호출이 렌더링 명령을 즉시 처리하게 되는데, 이는 GPU의 병렬 처리 효율을 떨어뜨릴 수 있어 사용을 제한하는 것이 좋습니다.

 공식 문서 및 참고 링크
Direct2D 앱의 성능 향상 가이드(Microsoft Learn) → D2D 사용 시 성능 최적화 방법과 리소스 관리 전략이 자세히 설명되어 있습니다.
//이건 그냥 D2D 문서.

D3D11On12 API를 활용한 텍스트 렌더링 사례(네이버 블로그) → 실제 DX12 환경에서 D2D를 활용한 텍스트 렌더링 구현 사례와 성능 이슈에 대한 경험이 공유되어 있습니다.
https ://m.blog.naver.com/wkdghcjf1234/221845350181

요약하자면, DX12에서 D2D를 사용하는 것은 가능하지만, 성능을 극대화하려면 리소스 관리, 병렬 처리, API 간 전환 비용 등을 면밀히 고려해야 합니다.혹시 훈철님이 직접 텍스트 렌더링 엔진을 구현 중이라면, GPU 기반 셰이더를 활용한 텍스트 버퍼링 방식도 추천드릴 수 있어요.원하시면 그쪽도 함께 탐구해볼까요 ?
-----------------------------------------------------------------------------------------------------------------------

일단 공식으로 나와있는 성능 저하의 문서는 없어보인다. 하지만, 다른 사람의 경험에서 성능저하가 나왔다고 하니, 불안해 보이는 방법이긴 하다.
음 이것만 추가하기 위해 굳이 gpu를 사용해 한번 더 다른 비트맵에 FLUSH 시키는
프로그래밍을 해야한다 ? 좀 의문이 들 수 밖에 없다.
그냥 차라리 비트맵 텍스쳐를 내가 실시간으로 제작하는건..아닌가 ?
FreeType과 같은 안티 에일리어싱도 필요 없는게 그냥 화면 렌더링을 안티 에일리어싱 하면 되겠다 생각했다.

일단 현재로써는 ttf정보를 이용해서 텍스트 렌더링 알고리즘을 만드는 것이 좋다고 판단된다. 그 이유는 다음과 같다.
1. ttf 정보를 사용하게 되면, 텍스트를 2d 텍스쳐 뿐 아니라, Mesh로도 표현이 가능해 활용성이 높아진다. (Mesh로 텍스트를 출력하는 작업은 이미 3D 프로그래밍 1 과제에서 해놔서 그걸 가져오면 된다.)
2. 글자의 렌더링 알고리즘 전체를 모두 만들기 때문에, 게임 안에서 다양한 텍스트의 움직임이라던가 모습이 나올 수 있다. ex> 글자의 간격에 점차 넓어지는 연출, 글자가 출렁거리는 연출, 발로란트 폰트 연출 - 부분적으로 길어졌다 짧아지는 연출(Mesh를 사용)
3. 글자 렌더링에 HLSL 셰이더를 쉽게 적용시킬 수 있다. 글자가 지지직 거리는 연출이나, 깜빡거리거나, 위치가 흔들리거나, 글자를 회전하고, 외곡하는 것도 쉽게 할 수 있다고 생각되었다.
>> 이는 모두 표현력의 향상으로 이어지며, 후에 게임을 만들때 특별한 연출로써 쓸 수 있다고 생각된다.

그러면 그렇게 해보자.

추가적으로 놓친게 없을까 해서 AI에게 물어보았다.
-------------- - microsoft_copilot---------------- -
질문 : DirectX 12 가 직접적으로 지원하는 텍스트 렌더링 방법은 없어?
답 : 없음.
DirectX 12 에서 텍스트 렌더링을 구현하는 방법은 이렇게 나뉨.
방법							설명											장점							단점
D3D11On12 + DirectWrite/Direct2D	DX11 기반의 텍스트 API를 DX12에서 사용하는 방식			빠른 구현, 한글 등 다양한 언어 지원	성능 저하 가능성, GPU idle 증가
글리프 텍스처 캐싱				글리프를 미리 텍스처에 렌더링하고, DX12에서 복사 및 배치	GPU 친화적, 비동기 처리 가능		초기 구현 복잡도 높음
Signed Distance Field (SDF)			글리프를 SDF로 변환 후 셰이더에서 렌더링				고해상도 확대에 강함, 	셰이더 기반	SDF 생성 및 셰이더 구현 필요
Bitmap Font 방식					고정된 글리프 이미지를 텍스처로 관리					간단한 구현					폰트 크기/스타일 유연성 부족

추가 질문 : SDF가 를 자세히 알려줘.
SDF란 무엇인가요?
Signed Distance Field는 픽셀마다 가장 가까운 경계(edge)까지의 거리를 저장한 텍스처입니다.
Signed: 거리에 부호가 붙습니다.
양수: 경계 바깥쪽
음수: 경계 안쪽
Distance: 경계까지의 거리
Field: 이 값들이 2D 텍스처 형태로 저장됨
이렇게 저장된 거리 정보를 셰이더에서 활용하면, 해상도에 구애받지 않고 텍스트나 아이콘을 부드럽게 렌더링할 수 있어요.
--------------------------------------------------------

SDF를 구현하는 것은 어렵지 않아 보인다.
단지 픽셀을 거리로 변경하고, 렌더링시에 거리에 따라 색깔을 달리하면 될 것 같다.
단지 알파블랜딩이 아직 없어서 적용되는걸 보는건 어렵겠지만..
일단 구현해보자.

일단 선의 방정식을 만들고 
xrange, yrange를 구하고 그중 너비가 넓은 것을 찾는다.
그 차원에서 값을 1씩 올리며 선상의 상대 차원의 값을 얻는다.
모든 선에 대하여 그렇게 수행한다.

그 후 도형데이터를 구축하여 한 점이 그 도형 내부에 있는지 검사를 한다.
이 검사는 그 도형을 이루는 선과 그 점으로 시작하는 반직선이 얼마나 많은 교점을 만들어내는 가로 내외여부가 판단된다.
만약 현재 픽셀이 체워져 있다면, 경계라는 뜻이므로, 다음 위치가 내부인지, 외부인지 함수로 판단하고, 내부면 체우는 모드로 바뀌고, 외부면 
넘어가는 모드로 바뀐다.

일단 그렇게 의도하고 코드를 작성하였다.

출력하는 방식은 일단 스크린에 일정하게 출력하는 방식을 먼저 구현하려 했다.
그래서 글자마다 Mesh를 일일히 만들어주는게 귀찮고, 비효율이라 생각했다. 
RootConstant로 해당 글자의 Rect 범위만 알려주고, 그것을 기반으로 다음 파이프라인 단계에 전달할 정점의 위치를 계산한다.
그후 텍스쳐를 이용해 글자를 렌더링 하고, HLSL의 discard; 문을 이용해 a가 0이면 제외시킨다.
그렇게 생각했는데, 버택스 셰이더를 4번 실행하려면 어찌되었든 점이 있어야 했고,
모든 글자에 공통으로 사용할 하나의 메쉬(점이 4개, 인덱스6개인)를 만들고, 그것을 기반으로 출력을 하게 했다.

다 만들었고 이제 시험을 할 차례이다.
그런데 아무리 해도 안보이고 PIX로 둘러보아도 안보이고..
디버깅을 해봐도 잘못된건 없어보여서 
추측 리스트를 만들어 하나하나 점검했다.

왜 안보이는가?
1. depth가 0이라? x
2. 위치 조정이 -1, 1로 안되어서? x
3. uv 설정이 잘못되어서? x
4. 와인딩 오더가 잘못되어서? x
5. depth 값을 잘못 조정해서? x

매우 많은 노가다 끝에..
float rect[4]; 라는 상수버퍼의 맴버를 RootConstant로 입력하는 게 오류가 났다는걸 알았음.
그래서 그냥 float4로 바꾸었다.
사실 원래는 배열의 원소를 찾아가는 편이 vertexID로 분기를 사용하는 것보다 더 효율적이라 생각해서 였다.
지금은 그냥 되니까 분기를 사용한다. 어짜피 점 4개이긴 하다. 낭비되는 시간은 짧을 것 같다. 아마..?
사실 잘 모른다.
일단 출력을 해결했다.

그리고 텍스트 이미지가 잘 구성되는지 확인하기 위해 절차마다의 이미지 디버깅이 필요했다.
지원하는 확장을 찾아봤는데 Image Watch 확장을 설치해서 사용해 봤다. OpenCV가 없으면 안되는 것 같아서 포기하고,
그냥 예전에 만들었던 raw한 이미지 데이터를 bmp이미지로 파일출력하는 코드를 가져와 이미지 디버깅을 했다.
Utill_ImageFormmating.h다.
테스트 하지 않은 이미지 구성 코드는 오류가 많았다.

어느정도 오류를 고치고 나서, 다시 봤는데 너무 느리다.
애초에 글자 하나에 1000*1000 만한 용량에 이미지를 구성하니까 느리기도 하고, 
나중에는 새로운 글자와 새로운 폰트 사이즈가 나타날 때마다 비트맵 텍스쳐를 구성해야 겠다 생각했다.
그리고 멀티스레드를 활용해서 Event를 요청하고 비트맵이 완성되면 다시 이벤트를 완료했다는 신호로 보내는 방식으로
비트맵 로드를 해야 게임이 안 멈추고 돌아가면서 텍스트 렌더링도 자유롭게 될 수 있을 것 같다는 생각을 했다.

polygons의 선이 게속 연결될 테니까 두 도형의 분리가 이루어지지 않음.
아직도 일일히 내부의 여부를 탐색해도 오류가 나는 문자가 많다.
때문에 polygon이 잘 들어갔는지, 정말 모든 점들을 포함하는지 확인해야 한다. 

결과를 보니
일부 가로줄은 한번의 경계를 만난후, 다음 점이 선 외부에 있다고 계산되어서 이후의 색이 반전되는 현상이 나타난다.
그래서 채우는 방식을 바꾸기로 했다.

왼쪽 위부터 오른쪽 아레로 가면서,
내부 외부를 탐색하지 말고, 만약 픽셀열을 만나게 되면, 다음 픽셀열까지 칠하고 다음 인덱스를 다음 빈 공간에 위치시킨다.
이를 반복하여 칠한다.
이렇게 했더니 대부분 채워졌지만, 오류가 나는 부분이 생겼는데, 선과 선을 만나게 하는 꼭짓점에서 다음 픽셀열은 외부와의 경계가 되는 문제가 생겼다.

이를 해결하기 위해
칠할때, 만약 자신의 바로 위의 픽셀이 채워지지 않았다면 채우지 않는 방식으로 칠한다. 그리고 다시 역 방향으로 채워진 곳을 탐색하고 그것을 다음 픽셀로 잡는다.

만약 위의 픽셀이 체워지지 않았다면, 한 행의 작업이 끝난 후,
또 내부 픽셀을 채우기 위해 해당 행에 대하여 한번더 같은 작업을 반복한다.

이렇게 했더니 대부분의 글자가 완전하게 구성되었지만, 첫번째 글자 'H'에서 오류가 났다.
이러한 방식은 선과 선을 만나게 하는 지점이 있고 난 후, 외부의 경계면이 마지막에 있을때 잘 작동하지 않는다.
때문에 이를 처리하기 위해..

만약 체워져서 들어왔는데, 마지막 원소인 경우에, 다시 한번 해당 행에 대하여 마지막으로 픽셀을 체운 첫번째 xi부터 같은 작업을 반복한다.