코드를 쓰는 시간보다 오류를 고치는 시간이 많은 경우.
>> 왜 이런 일이 발생??

1. 오류가 생기는 기술적인 원인은?
	- 결국 우리가 의도하지 않은 메모리 부분에 잘못된 값이 들어가 있어서, 의도하지 않은 방식대로 프로그램이 작동.
2. 그럼 오류를 고치기 위해 어떻게 해야 하는가?
	- 잘 돌아갈때까지 노가다? >> 뭐든 하나만 걸려라? >> 노노노
	- 왜 그 오류가 생겼는지 파악.(어떤 순간에 어떤 메모리에 의도하지 않은 것이 들어갔는가?) >> 그럼 어떻게 고쳐야 하는지 알아볼 수 있다.(아 이래서 메모리에 이상한게 들어갔구나. 그래서 코드를 이렇게 고쳐야 하는구나!) >> 오류를 만들어내는 코드를 고치기.

런타임 오류가 생기면 백이면 백 이런 상황. (기기가 망가진 경우를 제외하고. - 거의 없는 상황)

실수를 보완
3. 오류가 생기는 작업적인 원인은?
	- 결국 사람의 사소한 실수.
	- 코드가 완성되지 않았는데 다른 곳으로 눈을 돌리는 경우.
	- 어떻게 실행되는지 알 수 없는 코드를 작성하고 주석을 하지 않은 경우.
	- 자신이 무엇을 해야 할지 명확히 알지 못하고 코드를 적는 경우.
		- 앞으로 해야 할 일을 작성해주는 것이 좋다.
	- 문법을 지키는 것에 신경을 쓰지 않는 경우. { } 열고 닫는 문제, ; 없어짐, .. >> 컴파일 오류
	(실수한 사람은 자신이 실수했는지 알지 못한다. 다른 사람이 실수가 있다고 말하더라도 찾아내지 못한다.) >> 극복방법? 
		1. 서로 서로의 코드를 감시하기 (내가 보지 못한건 다른 사람이 더 잘 볼 수 있음.)

Context - CPU랑 메모리가 코드를 실행할때, 어떤 순간의 상태 문맥.
Context != codeline

4. 우리는 오류를 고칠때 어떻게 하는가?
	1. 오류를 발견한다.
	2. 오류를 재현할 수 있는지 확인한다.
		- 재현할 수 없는 오류? >> 이게 진짜 헬임. >> 완전 추정을 하거나, 오류가 생길때 까지 
중단점 찍고 프로그램을 돌려야 함. >> 지옥.
	3. 오류가 어떤 Context에서 일어날지 추정을 한다.
	4. 해당 Context를 디버깅을 통해 확인한다.
	5. 발견하지 못하면, 3번으로 돌아간다. 발견한다면, 실제로 왜 메모리에 이상한 값이 나는지 확인한다.
	6. 코드를 고치고, 오류가 고쳐졌는지 확인한다.

5. 디버깅의 방법 Visual Studio (습관화가 필요함. 필요할때 빛처럼 빠르게 쓸 수 있어야 함.)
	- Context 찾기 (중단점)
		- 최적화의 경우 - 디스어셈블리 보기
		- 프로세스 - 스레드 - 호출 스택
		- 디버깅 카운팅
	- 코드 원하는 방향으로 나아가기
		- 앞으로 나아가기
		- 함수 안으로 들어가기
	- 메모리를 보는 방법
		- 조사식
			+ 디스어셈블리시 레지스터도 볼 수 있다.
			+ 조사식 내부의 연산
		- 메모리 보기
		- 직접 실행 창
	- 로그 찍기 (출력창)
		- 디버깅을 할 수 없을때 (시간이 중요한 작용을 하는 프로그램)
		- 오류가 나도 이어서 처리할 수 있는 경우.
		- 어디에서 오류가 일어나는지 도저히 알 수 없는 경우에 사용. (온갖 곳에 로그를 작성) >> 다시 치우기 어려움.
	- 덤프 파일 생성
		- 할 수는 있음. (Visual Studio에서 지원)
		- 우리가 만들수도 있음 (메모리 관리 잘하면..)

6. 오답노트 작성
	- 결국 디버깅을 잘해도 오류를 잘 고치는 거지, 오류가 줄어들지는 못함.
	- 오류가 줄어들지 않으면 결국 개발속도는 한계에 봉착할 것.
	- 무언가 새로운것을 개발하는 속도도 현재 빠르지 않다. 때문에 


우리는 스스로 잘못을 지적할 필요가 있다.


	- 오답노트를 쓰면 됨. -> 그리고 그걸 수시로 보고 적용시키면 됨.
		쓰는 방법 : 잘못된 코드 >> 왜 잘못되었는지 이유를 적고 >> 그걸 어떻게 고칠건지 적자.
		적용 방법 : 수시로 보고, 코드 쓸때마다 다 떠올리진 않아도 좋으니까 하나씩이라도 신경쓰면서 코드를 적기
			- 한번에 많은 실수가 나오진 않을 것임. >> 가장 최근의 잘못을 떠올리는 것도 좋은 방법.