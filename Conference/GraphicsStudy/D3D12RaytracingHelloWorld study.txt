/*
/////////////////////////////////////////////////////////////////////////////
문서화 규칙
>> link				: 이 링크로 가시오 Ctrl F #link
#link				: 참조된 부분 -> 다시 이전으로 돌아갈려면 Ctrl F link
[]					: 알아낸 사실

// AI <AI이름> start
<내용>
// AI <AI이름> end	: AI로 부터 얻어온 지식

/////////////////////////////////////////////////////////////////////////////

DXC dll 로드, IDxcCompiler 인터페이스를 얻어서 컴파일.


Raytracing 공부 001

이제 드디어 레이트레이싱을 공부할 것이다.
시작은 D3D12RaytracingHelloWorld 공식 샘플 프로젝트로 시작한다.

<Main.cpp>
WinMain 함수가 있다.
해당 함수에서 
D3D12RaytracingHelloWorld 객체 sample을 생성한다.  -> not use 001
그것을 이용해 
Win32Application::Run 함수에서 프로그램을 실행한다.

<Win32Application.cpp>
@int Win32Application::Run(DXSample* pSample, HINSTANCE hInstance, int nCmdShow)
일단 간단히 봐서는 윈도우 초기화, CreateWindow를 한다.
그 후 pSample->OnInit을 한다. >> use 001
그 후 ShowWindow를 통해 윈도우를 보여준다.
그 후 PeekMessage로 메시지 루프를 돈다.
프로그램이 끝나면 pSample->OnDestroy를 호출한다.

#use 001
<D3D12RaytracingHelloWorld.cpp>
@void D3D12RaytracingHelloWorld::OnInit()
1. m_deviceResources 에 새로운 리소스를 생성한다.
FrameCount가 depth처럼 들어가니 RenderTarget 같다.
>> 특이한건 피쳐레벨이 D3D_FEATURE_LEVEL_11_0 이라는 것.
DeviceResources::c_RequireTearingSupport, // question
이 리소스는 DeviceResources 클래스 생성자로 생성한다. 이 부분을 볼 필요가 있다.
리소스 생성은 뭐가 다른지 말이다. >> 봤더니 리소스 생성은 아니고, 이것도 그냥 값 복사다. >> not use 002

2. m_deviceResources->RegisterDeviceNotify(this);
이건 뭐하는 놈일까 보자. 함수 이름의 뜻은 그냥 디바이스를 등록하는 거다.
>> use 003 
[DeviceResource는 내 프로젝트에서의 GlobalDevice같은 역할을 한다.
GPU 어답터, 커맨드 큐, 리스트, 할당자, DXGI Factory, 스왑체인, 렌더타겟, 뎁스스탠실, 팬스, RTV Desc Heap, DSV Desc Heap, ViewPort 등이 한 곳에 들어있다.]
[Raytracing이 지원되는 버전 부터는 디바이스 제거를 처리하는 애플리케이션이 스스로를 그렇게 할 수 있다고 선언이 필요한데, 그 작업을 한다.]

3. m_deviceResources->SetWindow(Win32Application::GetHwnd(), m_width, m_height);
이것도 그냥 디바이스 리소스에 화면 비율 관련 변수를 초기화하는 것이다.

4. m_deviceResources->InitializeDXGIAdapter();
아마 GPU 를 선택하는 것 같다. 뭐 다른거 있나만 보고 넘어가자.
엄 생각보다 기니까 봐야 될듯.
>> 보니까 그냥 디버그 레이어 생성하고, DXGI팩토리를 만드는 코드가 있다.
그 후 InitializeAdapter 함수를 호출한다.
해당 함수 내부에서 어댑터를 선택하여 실제 Device를 만들진 않고,  D3D12CreateDevice 함수를 통해 Direct3D 12 를 지원하는지 확인한다.
만약 디바이스를 만드는 데 실패하였다면, EnumWarpAdapter 를 통해 CPU 기만 Device 를 제작을 시도해 지원을 확인한다.

5. 그 후 IsDirectXRaytracingSupported 함수를 통해 이 GPU 어댑터가 Raytracing을 지원하는지 확인한다. 해당 함수는 그냥 가져다 쓰면 되겠다.
[GPU 어댑터가 Raytracing을 지원하는지 확인하기 위해서는 IsDirectXRaytracingSupported 함수를 이 샘플에서 가져가서 사용하자.]

6. deviceResource에 CreateDeviceResources 함수를 호출하여
	6-1. D3D12 API Device를 만든다. (이미 만든거 아니었나? >> 아님. 그건 그냥 지원하는지 보는 테스트 코드였다.)

	6-2.
	//AI microsoft copilot start
	그 후 DEBUG 모드일 경우 
	d3dInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
	d3dInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
	다음과 같은 코드를 진행하는데, 디버그시 일정 수준의 문제가 발생하면 디버거가 자동으로 중단되도록 하는 장치라고 한다.
	//AI microsoft copilot end

	6-3. CommandQueue를 DIRECT Mode로 만든다.
	6-4. RTV Desc Heap을 만든다.
	6-5. DSV Desc Heap을 만든다.
	6-6. backBufferCount(3) 만큼 CommandAllocator를 DIRECT 모드로 만든다.
	6-7. 0번째 CommandAllocator를 이용해 0번째 CommandList를 DIRECT 모드로 만든다.
	6-8. Fence 객체를 만든다.

7. 그 후 deviceResource의 CreateWindowSizeDependentResources 함수를 호출한다.
	말 그대로 화면 사이즈에 영향을 받는 리소스들을 생성하는 것 같다.
	다만 의문점은 같은 이름의 함수가 두줄 아래에 써져있는데, 왜 이름이 같은걸까?
	일단 첫번째 CreateWindowSizeDependentResources 부터 보자.
	7-1. WaitForGPU 를 통해 GPU 작업이 끝날때까지 기다린다.
	7-2. 렌더타겟을 Release 하고 Fence value를 업데이트 한다.
		 m_fenceValues[n] = m_fenceValues[m_backBufferIndex]; // quest 왜 이렇게 업데이트?
	7-3. 만약 스왑체인이 이미 있다면 ,
		m_swapChain->ResizeBuffers를 호출하여 운영체제 화면버퍼를 바꾼다.
		그리고 그걸 못할때의 에러처리를 한다.
		
		만약 스왑체인이 없다면 CreateSwapChainForHwnd을 통해 스왑체인을 만든다.
		[Tearing : 서로 다른 프레임의 일부가 동시에 표시되어 이미지가 수평으로 찢어진 듯 보이는 현상입니다.]
		그리 풀 스크린 제어도 하는 것 같다.
		만약 Tearing Support가 enable 되었다면, ALT+Enter로 DXGI SetFullscreenState를 호출되게 할 수 있다.
	7-4. SwapChain->GetBuffer를 호출해 실제 사용할 RenderTarget을 얻고, RTV를 만들어 Desc Heap에 저장한다. m_backBufferCount(3) 개씩.
		렌더타겟 버퍼 인덱스를 얻는다.
	7-5. DepthStencil Buffer, DSV를 만든다.
	7-6. 뷰포트, 시저렉트를 설정한다.

8. D3D12RaytracingHelloWorld의 CreateDeviceDependentResources 함수를 생성한다.
	8-1. CreateRaytracingInterfaces : Raytracing Device와 CommandList를 생성함.
		>> 내부를 보면 생성을 하는 것이 아니고, 
			기존 디바이스가 D3D12Device5 로 쿼리가 되는지, 
			기존 커맨드 리스트가 ID3D12GraphicsCommandList4 로 쿼리가 되는지 확인하는 것이다.
	8-2. Shader를 위한 RootSignature 생성
		[Raytracing RootSignature를 생성하기 위해서는
		RootParameters 배열만 있다면 생성이 가능하다.
		Param은 DX12와 그 타입이 같다.
		그것을 사용해 CD3DX12_ROOT_SIGNATURE_DESC를 구성하고,
		SerializeAndCreateRaytracingRootSignature 함수를 사용해 
		RootSignature를 만들어낸다.]
		
		8-2-1. Global Root Signature 생성 
			: [Global Root Signature : 기존 DX12 RootSignature와 같은 것임.]
			0번은 UAV Descriptor Table이 하나가 들어간다.
			1번은 Descriptor SRV가 Acceleration Structure 를 위한 슬롯으로 쓰기 위해 들어간다.
		8-2-2. Local Root Signature 생성 
			: [Local Root Signature : 각각의 충돌시 적용되는 충돌마다 다른 RootSignature.]
			0번은 Constant로 들어간다. 크기는 RayGenConstBuff의 사이즈로 들어가는 것 같다.
			RayGenConstBuff를 보자 >> use 004
			결국 뷰포트 RECT 정보 두개가 들어간다. 하나는 뷰포트, 하나는 스텐실 뷰포트? 라고 되어 있음.
	8-3. Raytracing Pipeline State Object(RTPSO) 생성.
		주석에는 이렇게 적혀있다.
		RTPSO에 결합되는 7가지 서브 오브젝트를 만든다.
		각 서브오브젝트는 기본적/명시적으로 DXIL 익스포트와 연관될 필요가 있음.
		<기본 연결>은 <동일한 유형의 SOTAL가 연결되지 않은> 모든 <내보낸> 
		<셰이더 진입점>에 적용됩니다.
		그러니까 셰이더 진입점이 <동일한 유형의 SOTAL가 연결되지 않은 진입점>
		<내보낸 진입점임.> 셰이더 진입점이 뭐냐..? shader entry point??
		진입점이 동일한 유형의 SOTAL가 연결되지 않은,??
		이 샘플은 <로컬 루트 시그니쳐>를 제외한 <기본 셰이더 연결>을 사용합니다.
		순전히 시연 목적으로만 명시된 연관성을 가지고 있습니다. 라고 한다.

		연결에 관련된 이야기는 이전에 소개되었던 
		[SubObject to associate to Local Root Signature에 대한 이야기 같다.
		이것은 Hit Group과 Local Root Signature를 연결하는 역할을 한다.
		나만의 약자로 나타내면 SOTAL(소탈) 이라고 해야지..]
		앞의 주석을 요약하자면 이렇다. 
		SOTAL들은 모두 명시적 연결 혹은 기본적 연결 중 선택을 한다.
		그중 기본적 연결을 선택하면, 
		동일한 유형의 SOTAL(같은 기본적 연결중?)이 연결하지 않은 모든 셰이더 진입점에 적용됨.
		그럼 기본 STOAL은 다른 기본 SOTAL이 연결하지 않은 셰이더 진입점에 연결을 할 수 있다는 말로 번역됨.
		셰이더 진입점이란 뭘까 생각해보니 raytracing은 ray가 어디에 충돌하느냐에 따라 진입점(함수의 시작점)이 달라진다. 그 진입점 아닐까?

		[RTPSO 에 들어가는 서브오브젝트들은 다음과 같다.
		DXIL lib
			raytracing은 ray가 어디에 충돌하느냐에 따라 호출되는 함수가 달라진다.
			해당 함수들을 모아놓은 Lib를 등록한다.
		Triangle Hit group
			Geometry와 Ray가 충돌했을때 호출될 Shader 함수 집합
		Shader config
			Ray가 충돌-반사할 때마다 Payload에 스택처럼 데이터를 쌓는다.
			해당 Payload의 최대크기를 설정한다.
			attribute도 설정한다고 한다. ??? 이게 뭔가?
		Local RootSignature and SOTAL
			SOTAL 설정
		GlobalRootSignature
		Pipeline config
			ray의 가능한 충돌 횟수. recursion count를 결정한다.]

		CD3DX12_STATE_OBJECT_DESC raytracingPipeline{ D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE };
		CD3DX12_STATE_OBJECT_DESC 구조체를 통해 파이프라인 정보를 담는 것 같다.

		8-3-1. DXIL 설정
		auto lib = raytracingPipeline.CreateSubobject<CD3DX12_DXIL_LIBRARY_SUBOBJECT>();
		를 통해 CD3DX12_DXIL_LIBRARY_SUBOBJECT 정보를 만든다.
		그리고 Shader Bytecode를 만들어 libdxil 에 저장하고, //quest (진짜 data에 바이트상태로 저장되어 있어서 뭔지는 모르겟음.)
		lib->SetDXILLibrary(&libdxil);를 통해 DXIL라이브러리를 설정한다.
		그 후 lib->DefineExport(L"<ShaderFunctionName>"); 을 통해 
		뭔가 진입점 함수들을 정의하는 것 같음.

		8-3-2. Triangle Hit Group
		이 샘플에서는 오직 TriangleGeometry-closestHit 셰이더만 사용하고, 나머지 설정은 안함.
		 auto hitGroup = raytracingPipeline.CreateSubobject<CD3DX12_HIT_GROUP_SUBOBJECT>();
		 로 히트그룹 서브오브젝트를 만든다.
		hitGroup->SetClosestHitShaderImport(c_closestHitShaderName);
		해당 히트 그룹에 Shader를 연결한다?
		hitGroup->SetHitGroupExport(c_hitGroupName);
		히트그룹 이름을 설정하는 것 같은데 왜 설정하는지 이유를 모르겠음.
		hitGroup->SetHitGroupType(D3D12_HIT_GROUP_TYPE_TRIANGLES);
		히트그룹에 바인딩되는 프리미티브에 따라 타입을 지정해주어야 하는 것 같다.

		8-3-3. Shader Config
		CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT 를 이용해 config 서브 오브젝트를 설정한다.
		해당 오브젝트의 Config 함수를 호출해 payload의 사이즈와 atrribute의 사이즈를 설정한다.

		8-3-4. Local Root Signature
		@CreateLocalRootSignatureSubobjects
		주석에 <이 셈플에서 히트 그룹과 미스셰이더는 로컬루트시그니쳐를 쓰지 않기 때문에, 그것을 설정은 안함.>
		-> 실제로는 미스셰이더나, 히트그룹에도 로컬루트시그니쳐가 쓰일 수 있다.
		실제로 여기에서 만드는 LocalRootSignature는 RayGenShader의 것이다.
		Pipeline을 통해 CreateSubobject<CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT>();
		을 써서 local Root Signature 서브오브젝트를 생성하고, 8-2에서 이미 만들어진 local Root Signature인 m_raytracingLocalRootSignature를 사용해 서브오브젝트에 Set한다.
		
		그후 CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT
		를 이용해 SOTAL을 만들고, 
		rootSignatureAssociation->SetSubobjectToAssociate(*localRootSignature);
		rootSignatureAssociation->AddExport(c_raygenShaderName);
		을 통해 SOTAL을 연결한다.

		8-3-5. Global Root Signature
		CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT 으로 서브오브젝트 만들고
		globalRootSignature->SetRootSignature(m_raytracingGlobalRootSignature.Get());
		로 글로벌 루트시그니쳐를 설정한다.

		8-3-5. 그 후 Pipeline Config를 CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT
		로 만들고, recursion depth 를 1. ray가 한번 쏘고 반사되지 않게 한다.
		UINT maxRecursionDepth = 1; // ~ primary rays only.
		pipelineConfig->Config(maxRecursionDepth);

		8-3-6. 만약 디버그모드의 경우 PrintStateObjectDesc를 호출한다.

		8-3-7. 설정한 Pipeline 데이터를 가지고 StateObject를 생성한다.
		m_dxrDevice->CreateStateObject(raytracingPipeline, IID_PPV_ARGS(&m_dxrStateObject));

	8-4. Shader Visible Desc Heap 생성
	8-5. 샘플에 사용될 Geometry를 빌드한다.
		- m_vertexBuffer 리소스에 버텍스 버퍼를 만들고 m_indexBuffer 리소스에 인덱스 버퍼를 만든다.
		- 만드는 방식은 기존과 같은것 같다.
	8-6. Acceleration Structure를 빌드한다.
		- 빌드에 GPU 실행이 필요한 것 같다. 커맨드 리스트에 명령을 많이 집어넣는다.
		@void D3D12RaytracingHelloWorld::BuildAccelerationStructures()
		
		8-6-1. Geometry 생성
		D3D12_RAYTRACING_GEOMETRY_DESC 를 작성한다.
		Type : D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES - 프리미티브 설정하는 것인것 같다.
		Triangles.IndexBuffer = 인덱스 버퍼 리소스의 GPU 가상주소
		Triangles.IndexCount = 인덱스 개수
		Triangles.IndexFormat = DXGI_FORMAT으로 되어있는 인덱스 데이터 포맷
		Triangles.Transform3x4 = 0; ??quest -> 뭔가 월드 내의 회전과 월드 변환을 나타내는듯.
		Triangles.VertexBuffer.StartAddress = 버택스 버퍼 리소스의 GPU 가상주소
		Triangles.VertexBuffer.StrideInBytes = 버택스 하나의 바이트 크기
		Triangles.VertexCount = 버택스 개수
		Triangles.VertexFormat = DXGI_FORMAT으로 되어 있는 버택스 데이터 포맷
		Flags -> quest : 아마 플래그를 설정, 어떤 설정적용?
		
		geometryDesc.Flags = D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE;
		이 플래그에 붙여진 주석이 있다.
		그 주석은 다음과 같이 쓰여져 있다.
		지오메트리가 불투명객체라는걸 마킹한다.
		성능을 위한 팁 : 불투명 객체로 플래그로 마킹을 하면 내부적으로 중요한 광선 처리 최적화를 함.
		+ 광선이 불투명한 기하학을 만나면 anyHitShader가 실행되지 않는다.

		8-6-2. Acceleration Structure 만들기
			AS를 만들기 위한 세가지의 리소스
			1. Scractch Resource : AS 빌더가 내부적으로 사용하는 리소스
			2. AS Resource : 실제 AS가 저장되는 리소스
			3. TLAS에 저장될 <AS를 가리키면서 world 변환까지 저장되는> AS Instance Desc.

			8-6-2-1. D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS
			빌드 플래그라는 걸 설정함.
			D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE
			이건데.. 빠른 트레이스를 선호하는 플래그?
				
			D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS 구조체를 초기화한다.
			topLevelInputs으로 한다.
			맴버변수
			DescsLayout = ?
			Flags -> 여기에 빌드 플레그가 들어감.
			NumDescs -> Desc의 개수? 지금은 1개라 되어있음.
			Type -> D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL (Top		Level임.)
			[
			TLAS인 경우 Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL,
			BLAS인 경우 Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL.
			]
			//quest D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_OPACITY_MICROMAP_ARRAY -> 이건 뭐냐?

			8-6-2-2. D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO
			m_dxrDevice->GetRaytracingAccelerationStructurePrebuildInfo
			함수를 통해 PreBuildInfo를 얻는다. 매개변수는 이전에 설정한 
			D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS인 topLevelInputs을넣는다.
			topLevelPrebuildInfo.ResultDataMaxSizeInBytes > 0 이여야 성공이라 한다.

			1-2 과정을 bottomLevelInput, bottomLevelPrebuildInfo에도 반복한다.
			차이점은Type이 다르다는거,
			그리고 pGeometryDescs 맴버변수에 이전에 만들었던 geometryDesc을 넣는 것이다.

			8-6-2-3. 무슨 역할을 하는지 모르겠는 ScratchResource를 생성한다.
			사이즈는 
			topLevelPrebuildInfo.ScratchDataSizeInBytes
			bottomLevelPrebuildInfo.ScratchDataSizeInBytes
			중 최대값을 선택했다.
			UAV로 만든다.

			8-6-2-4. Accelaration Structure Resource(ASR) 만든다.
			[ASR는 DEFAULT HEAP 에 생성된 리소스만 허용됨.
			ASR를 포함할 리소스는 D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE 상태로 생성되어야 합니다. 
			또한 리소스 플래그 D3D12_RESORCE_FLAG_ALLOW_UNORDERED_ACESS가 있어야 합니다.
			ASR은 UAV임.]
			AllocateUAVBuffer함수를 사용해 TLAS Resource, BLAS Resource 생성한다.

			8-6-2-5. Bottom Level Acceleration Structure를 위한 
			Instance Desc 를 생성?? 이게 뭔데.. // quest
			일단 이것을 생성하기 위해서는, 
			GPUResouce 하나, 그리고 D3D12_RAYTRACING_INSTANCE_DESC 구조체 설정 필요하다.
			instanceDesc.Transform[3][4] 에서 단위행렬을 만들고,
			instanceDesc.InstanceMask = 1;
			instanceDesc.AccelerationStructure = m_bottomLevelAccelerationStructure의 GPU 가상주소를 넣는다.
			그리고 특이하게도, 만든 D3D12_RAYTRACING_INSTANCE_DESC값을 그대로 
			instanceDesc Resource에 Upload하는 것 같다.

			8-6-2-6. 
			D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC을 
			toplevel, bottomlevel에 대해 구성한다.
			ScratchAccelerationStructureData 에 만들었던 scratchResource의 GPU가상주소를, 
			DestAccelerationStructureData 에 만들었던 TLAS나 BLAS Resource의 GPU 가상주고를 넣는다.

			8-6-2-7. AS를 빌드한다.
			일단 여기에서는 람다로 하긴 하는데, 그냥 함수다.
			그 함수의 작동은 다음과 같다.
			raytracingCommandList->BuildRaytracingAccelerationStructure(&bottomLevelBuildDesc, 0, nullptr);
			AS를 빌드한다.
			commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::UAV(m_bottomLevelAccelerationStructure.Get()));
			UAV의 STATE로 바꾸는 Resource Barrier를 추가한다.
			그후
			raytracingCommandList->BuildRaytracingAccelerationStructure(&topLevelBuildDesc, 0, nullptr);
			이것을 통해 TLAS도 빌드한다.
			TLAS는 왜 UAV로 변환안하는지는 모르겠다.

			그후 쌓인 커맨드리스트를 실행하고, 
			WaitForGPU로 GPU가 끝날때까지 기다린다.
	8-7. Shader Table을 빌드한다.
		8-7-1. ShaderId들이 있다. void* 로 되어있는 거 보니 8바이트인가보다.
		void* rayGenShaderIdentifier;
		void* missShaderIdentifier;
		void* hitGroupShaderIdentifier;

		ID3D12StateObjectProperties를 m_dxrStateObject를 캐스팅해 만든다.
		그리고 프로퍼티의 맴버함수 GetShaderIdentifier를 호출해,
		셰이더 함수 이름을 매개변수로 넣고 셰이더 ID를 받는다.

		ShaderTable은 Shader의 타입마다 다른 테이블이 필요하다.
		이 예제에서는 
		Ray gen shader table
		Miss shader table
		Hit group shader table (closest, any hit)
		을 만들고 있다.

		Ray gen shader table
		RootArgument라는 구조체를 만들어 맴버변수로 
		RayGenConstantBuffer 구조체(아따 Viewport 2개 있었던 그 구조체.)
		의 인스턴스를 사용.
		이 RootArgument 구조체에 콘스턴트 버퍼말고 다른게 들어갈 수도 있겠다.
		HelperLib의 ShaderTable 구조체의 생성자를 이용해 셰이더 테이블을 만드는 것 같다.
		push back 함수를 통해 ShaderRecord를 넣는다.
		ShaderRecord에는 RayGenShaderId, ShaderIdSize, RootArgument, sizeof(RootArgument) 가 들어간다.

		MissShader와 HiGroupShader도 같지만
		Argument 구조체가 없고, 
		ShaderRecord에 Argument가 들어가지 않는다는 점에서 다르다.

	8-8. Raytracing Output Resource를 생성한다. (서브 렌더타겟인듯.)
		서브렌더타겟을 UAV디스크립터와 함께 만든다.

		//For simplicity, we will rebuild the shader tables. ?? 
		-> 간단함을 위해 우리는 셰이더테이블을 다시 빌드한다??
		>> 안해도 될것 같은데?
		-> 일단 안해도 실행은 된다.

남은건 OnUpdate와 OnRender이다.
OnUpdate >> not use 3

<D3D12RaytracingHelloWorld.cpp>
@void D3D12RaytracingHelloWorld::OnRender()
윈도우가 안보이는 상태이면 return.
1. m_deviceResources->Prepare();
	렌더링 준비
	1-1. CommandAllocators와 CommandList를 Reset한다.
	1-2. (서브인지 스왑체인인지 모를) 렌더타겟의 상태가 RENDER_TARGET이 아니면, 그것으로 바꾼다.
2. DoRaytracing();
	레이트레이싱 실행
	2-1. SetComputeRootSignature으로 특이하게도 ComputeRootSignature를 사용함.
	2-2. ShaderVisibleDescHeap을 commandList->SetDescriptorHeaps으로 바인딩.
	2-3. commandList->SetComputeRoot~~ 으로 GlobalRootSignature의 Root변수를 설정함.
	2-4. m_dxrStateObject 으로 m_dxrCommandList->SetPipelineState1 함수로 파이프라인 설정
	2-5. D3D12_DISPATCH_RAYS_DESC 구조체를 설정하여 DispachRays를 호출한다.
		HitGroupTable, MissShaderTable의 StartAddress, SizeInBytes, StrideInBytes을 설정,
		RayGenerationShaderRecord의 StartAddress, SizeInBytes 설정.
		화면 Width, Height설정하고, Depth를 설정하면 된다.
3. CopyRaytracingOutputToBackbuffer();
	레이트레이싱 출력을 백 버퍼에 복사.
	CopyResource로 RenderTarget에 m_raytracingOutput을 복사한다.
4. m_deviceResources->Present(D3D12_RESOURCE_STATE_PRESENT);
	Present.
	4-1. RenderTarget의 State를 PRESENT로 바꾼다.
	4-2. CommandQueue의 ExecuteCommandLists를 사용해 커맨드를 실행시킨다.
	4-3. SwapChain을 사용해 Present한다.
	4-4. BackBufferIndex와 Fence를 업데이트한다.

#use 004
<RaytracingHlslCompat.h>
struct Viewport
{
	float left;
	float top;
	float right;
	float bottom;
};

struct RayGenConstantBuffer
{
	Viewport viewport;
	Viewport stencil;
}; // 32byte

#use 003
<DeviceResource.h>
@void RegisterDeviceNotify(IDeviceNotify* deviceNotify)
특이한 점은 매개변수 타입은 IDeviceNotify* 인데, 전달하는건 D3D12RaytracingHelloWorld*이다.
그건 D3D12RaytracingHelloWorld가 IDeviceNotify 상속을 하는 것 같다.
확인해보자. >> use 002
D3D12RaytracingHelloWorld가 DXSample 상속, DXSample이 IDeviceNotify 상속함.
그럼 한 샘플 프로그램의 데이터는 3곳에 있다.
IDeviceNotify, DXSample, D3D12RaytracingHelloWorld 이 세개의 클래스 맴버변수가 샘플의 변수다.

IDeviceNotify 는 그냥 디바이스 문제 생겼을때 처리하는 인터페이스라 데이터 없다.
DXSample는 특별한건 
// D3D device resources
UINT m_adapterIDoverride;
std::unique_ptr<DX::DeviceResources> m_deviceResources;
이것밖에 없다.
주석을 보니 디바이스 관련 리소스인것 같다. 근데 이거 아까 렌더타겟인것 같다 했으니까. Render 함수 찾아서 정말인지 확인해보자.

>> 결국 DeviceResource는 내 프로젝트에서의 GlobalDevice같은 역할을 한다.
GPU 어답터, 커맨드 큐, 리스트, 할당자, DXGI Factory, 스왑체인, 렌더타겟, 뎁스스탠실, 팬스, RTV Desc Heap, DSV Desc Heap, ViewPort 등이 한 곳에 들어있다.

이후 주석을 보니 이렇게 적혀있다.
//RS4 이상에서는 디바이스 제거를 처리하는 애플리케이션이 스스로를 그렇게 할 수 있다고 선언해야 한다.
뭔가 스스로 디바이스를 처리할 수 있다고 선언이 필요하다 한다.

RS4 이상이 뭔가?

// AI Microsoft Copilot start
RS4 = Windows 10 April 2018 Update (버전 1803).
DXR은 RS4부터 지원 -> 
따라서 주석의 의미는 "Windows 10 1803 이상 환경에서는 Raytracing 디바이스를 직접 관리해야 한다"는 뜻입니다.
// AI Microsoft Copilot end

##use 002
<D3D12RaytracingHelloWorld.h>
@class D3D12RaytracingHelloWorld
상속은 : public DXSample 이다.
그럼 DXSample이 IDeviceNotify를 상속하는 건가? >> 확인해 보니 그렇다. <DXSample.h>

##not use 001
#########################################
<D3D12RaytracingHelloWorld.cpp>
그러면 이어서 D3D12RaytracingHelloWorld의 생성자를 보고 어떻게 초기화되는지 보자.
DXSample의 생성자를 다시 호출한다.
그리고 
m_raytracingOutputResourceUAVDescriptorHeapIndex를 UINT 최대값으로 설정한다. (아마 NULL을 표현하고 싶었던 것 같다.)
m_rayGenCB.viewport = { -1.0f, -1.0f, 1.0f, 1.0f };

그럼 다음으로 DXSample의 생성자를 보자.

<DXSample.cpp>
WCHAR assetsPath[512];
GetAssetsPath(assetsPath, _countof(assetsPath)); // 현재 실행파일의 Path를 가져온다.
m_assetsPath = assetsPath;

UpdateForSizeChange(width, height);
// 이건 그냥 width, height, wh ratio 설정.
##########################################

##not use 002
#########################################
<DeviceResource.cpp>
@DeviceResources::DeviceResources(DXGI_FORMAT backBufferFormat, DXGI_FORMAT depthBufferFormat, UINT backBufferCount, D3D_FEATURE_LEVEL minFeatureLevel, UINT flags, UINT adapterIDoverride);
 봤더니 리소스 생성은 아니고, 이것도 그냥 값 복사다.
#########################################

##not use 003
#########################################
<D3D12RaytracingHelloWorld.cpp>
@void D3D12RaytracingHelloWorld::OnUpdate()
CalculateFrameStats 함수로 현재 FPS를 구하는 코드가 들어 있다.
#########################################

*/
