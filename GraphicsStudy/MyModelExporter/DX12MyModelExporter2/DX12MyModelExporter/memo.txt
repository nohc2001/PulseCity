계획.
1. 일단 값을 모두 다 읽어들인다.
	- animation 을 하나 불러들려서 Node name이 어떤 의미인지 확인해보자.
2. Mesh데이터를 사용해 Dx12로 출력할 수 있게 구성
3. 텍스쳐는 일단 사용하던 대로 구성.
4. PBR Shader 구현
5. dds 텍스쳐읽기로 바꾸기 / 밉맵도..
6. 이것을 bin으로 출력.

Shader Visible Descriptor Heap이 아닌 경우에는 GPU에서 볼 수 없기 때문에
Descriptor의 GPU HANDLE이 존재하지 않는다.
오직 CPU Descritpor HANDLE 만 존재하고 얻을 수 있다.

////////////////

XMVector4TransformStream : 행렬변환을 VECTOR 배열에 대해 모두 적용시키는 연산. 아마 일반적인 반복문보다 빠르게 수행할 것이다.

XMVector4AngleBetweenVectors : 두 벡터 사이의 각도를 구한다.
XMVector4AngleBetweenNormals : 두 단위벡터 사이의 각도를 구한다 (더 빠름)

XMVector4Orthogonal : 어떤 벡터의 수직인 벡터를 반환한다. (무슨기준으로 수직벡터를 결정하는지는 모름.) -> 코드를 봐야 할 듯.

XMVector4RefractV : 굴절벡터 계산하는 함수

XMVector4ClampLength : 벡터 길이의 최대와 최소를 받아 변환된 벡터를 반환합니다. -> 길이가 범위 안에 없으면 범위안으로 넣는 작업 하는듯.

XMVector4ReciprocalLength : 벡터 길이의 역수를 반환합니다.

XMVector4LengthSq : 벡터길이의 제곱을 반환합니다. 이게 더 빠름. sqrt연산을 안해도 됨.

XMVector4IsInfinite : 벡터의 요소중 하나라도 무한이면 true.
XMVector4IsNaN : 벡터의 요소중 하나라도 Nan 이면 true

XMVector4InBounds : 
//bound vector = {a, b, c, d} // xmin : -a, xmax : a ...
해당 바운드안에 위치벡터가 위치하는지.

XMVector3UnprojectStream
XMVector3Unproject : 이 둘은 화면 공간의 벡터를 
개체공간(게임공간)상의 벡터로 변환하는 작업을 한다.
Stream이 붙이면 여러개를 빠르게 처리 가능하다.

XMVector3ProjectStream
XMVector3Project : 개체공간의 벡터를 화면공간의 벡터로 변환한다.

XMVector3TransformNormalStream
XMVector3TransformNormal
: 위치이동을 지원하지 않는 변환함수로, w 값을 0으로 채운다.

XMVector3TransformCoordStream
XMVector3TransformCoord
: 위치 이동을 지원하는 변환함수로, w값을 1로 채운다.

XMVector3InverseRotate
XMVector3Rotate : 이건 쿼터니언으로 회전시키고, 역회전이나 복원하는 것.

XMVector3ComponentsFromNormal
	: 노멀벡터를 활용해 하나의 벡터를 두가지 벡터로 나누는데,
		노멀벡터와 같은 방향의 벡터하나와,
		해당 노멀을 가지는 평면 위의 벡터 하나로 나눈다.

XMVector3LinePointDistance
	: 선분과 점 사이의 거리를 얻는다.

XMVector3AngleBetweenVectors : 두 벡터사이의 라디안 각도
XMVector3AngleBetweenNormals : 두 단위벡터 사이의 라디안 각도

XMVector3Orthogonal

XMVectorBaryCentricV
XMVectorBaryCentric
XMVectorCatmullRomV
XMVectorHermiteV
XMVectorLerpV

XMVectorSin/Cos/Tan/aSin, aCos, aTan

XMVectorModAngles
XMVectorMod
XMVectorAbs
XMVectorPow
XMVectorLog
XMVectorExp

XMVectorReciprocalSqrt
XMVectorSqrt

XMVectorNegativeMultiplySubtract
XMVectorAddAngles

XMVectorNegate
XMVectorAnd, Or, Xor, Nor, Int

XMVectorSaturate
XMVectorClamp
XMVectorCeiling
XMVectorFloor
XMVectorTruncate
XMVectorRound

XMVectorMax
XMVectorMin

XMVectorInsert

XMVectorReplicate



///////////////

XMQuaternionBaryCentric;
XMQuaternionMultiply;
XMQuaternionConjugate;
XMQuaternionSlerpV;
XMQuaternionDot;
XMQuaternionEqual;
XMQuaternionExp;
XMQuaternionIdentity;
XMQuaternionIsInfinite;
XMQuaternionInverse;
XMQuaternionIsIdentity;
XMQuaternionLength;
XMQuaternionNormalize;
XMQuaternionLn;
XMQuaternionSquad;
XMQuaternionRotationAxis;
XMQuaternionRotationMatrix;
XMQuaternionRotationNormal;

XMPlaneDot;
XMPlaneNormalize;
XMPlaneDotCoord;
XMPlaneDotNormal;
XMPlaneFromPointNormal;
XMPlaneFromPoints;
XMPlaneIntersectLine;
XMPlaneIntersectPlane;
XMPlaneIntersectPlane;
XMPlaneTransform;
XMPlaneIsInfinite;
XMPlaneIsNaN;


/////////////
여기에서 부터 셰도우 매핑을 하기 위한 메모의 시작이다.
기본적으로 DirectX Sample의 예제 D3D12Multithreading의 셰도우 맵핑을 따라한다.

일단 필요한 것은
셰도우 매핑을 위한 셰이더 클래스일 것이다.
이는 하나의 버택스 셰이더를 가지고, 픽셀셰이더는 없다.
Root 변수로 MVP 행렬들이 필요하고, 이를 통해 물체들을 그려야 한다.
(SpotLight의 ViewFrustum안에 위치한 것들을 대상으로 그린다.)

이를 하기 위해 GPU동기화 작동을 두번 해서 렌더링 해야 하는지 의문이다.
물론 텍스쳐를 하나가 읽고, 하나가 쓰기 때문에, 리소스가 변하지만, 
결국 GPU안에서 있는 리소스이기 때문에, 만약 커맨드 리스트가 순서대로 동작한다면
Resource Barrier 를 할뿐, 그것때문에 동기화를 할 필요는 없지 않을까 생각했다.

또한 렌더링한 뎁스 스텐실을 어떻게 텍스쳐로 뽑아올 수 있는지도 생각해봐야 한다.
셰도우 맵 텍스쳐를 일단 만들고, 물체를 렌더링 하기 전에 D3D12_RESOURCE_STATE_DEPTH_WRITE에서 D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE로 바꾼다.
또한 셰도우 맵 렌더링을 할때를 위해 Depth Stencil View를 만든 텍스쳐를 통해 만든다.
그런데 이 view가 어떻게 셰도우 맵 렌더링 할때 전달되는가??
CommandList->ClearDepthStencilView 의 매개변수에 DepthStencilView의 CPU HANDLE을 매개변수로 받는 부분이 있다.

